# 42842 (카펫)
# 시간복잡도: O(yellow)
# for 루프에서는 1부터 yellow까지 반복하면서, yellow를 나눌 수 있는 가로 길이와 세로 길이를 구합니다. 이 때, yellow의 약수를 모두 구해보는 것이므로 이 루프의 시간 복잡도는 O(yellow)입니다.
# if 문에서는 구한 가로 길이와 세로 길이로부터, 주어진 brown 타일의 개수를 이용하여 카펫의 가로 길이와 세로 길이를 계산합니다. 이 때, 계산하는 것은 상수 시간이 걸리므로, if 문의 시간 복잡도는 O(1)입니다.
# 따라서 전체 함수의 시간 복잡도는 O(yellow)입니다. 이는 매우 작은 시간 복잡도이므로, 실행 속도가 매우 빠릅니다. 따라서 이 코드는 효율적인 알고리즘이라고 할 수 있습니다.

def solution(brown, yellow):
    answer = []

    y_x = 0
    y_y = 0

    # 1부터 노란색의 개수만큼 for문 반복하면서 노란색의 수가 i로 나누어 떨어지면 노란색의 가로는 노란색을 i로 나눈 몫이 되고, i는 노란색의 세로가 된다.
    # 이때 위에서 언급한 수식을 사용하여 answer 리스트에 y_x + 2와  y_y + 2를 넣어준다.
    # 가로가 세로보다 크거나 같아야 하기 때문에 내림차순으로 정렬한 후 반환
    for i in range(1, yellow + 1): 
        if yellow % i == 0:
            y_x = int(yellow/i)
            y_y = i
            if y_x * 2 + y_y * 2 + 4 == brown:
                answer.append(y_x+2)
                answer.append(y_y+2)

                return sorted(answer, reverse=True)
            
    return answer


# 처음 문제를 풀 때 입출력 예를 보니 brown과 yellow를 더한 수의 약수가 return 값으로 나오길래 약수를 이용해 푸는 문제인 줄 알고 그쪽으로 접근하여 문제를 풀었지만 아니었다,,,
# 결국 다른 분의 코드를 참고하여 풀이 함
# y_x * 2 + y_y * 2 + 4 == brown 과 같은 수식은 어떻게 생각해 내는건지..ㅠ 개인적으로 도형 관련 문제는 수학식과 관련된 문제 풀이가 많은 느낌이다. 이 쪽으로 생각을 더 넓혀야 할 것 같다........
