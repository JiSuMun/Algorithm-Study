# 탐욕법(Greedy)
# 섬 연결하기
# 시간복잡도: O(NlogN)
"""
1. 다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능

2. 임의의 i에 대해
    - costs[i][0] 와 costs[i] [1] : 다리가 연결되는 두 섬의 번호
    - costs[i] [2] : 이 두 섬을 연결하는 다리를 건설할 때 드는 비용

3. 같은 연결은 두 번 주어지지 않습니다.

4. 순서가 바뀌더라도 같은 연결로 봅니다.

5. 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.

6. 연결할 수 없는 섬은 주어지지 않습니다.
"""
from heapq import heappop, heappush

def solution(n, costs):
    graph = [[] for _ in range(n)]
    for island1, island2, cost in costs:
        graph[island1].append((island2, cost))
        graph[island2].append((island1, cost))
    visited = [False] * n
    # (비용, 섬)
    heap = [(0, 0)]
    res = 0
    # 힙정렬을 비용기준으로 했기 때문에 가장 적은 비용부터 => 최소비용
    while heap:
        cost, island = heappop(heap)
        if visited[island]: continue
        visited[island] = True
        res += cost
        for n_island, n_cost in graph[island]:
            if not visited[n_island]:
                heappush(heap, (n_cost, n_island))

    return res

"""
참고 테스트케이스
n / costs / res
7 [[2, 3, 7], [3, 6, 13], [3, 5, 23], [5, 6, 25], [0, 1, 29], [1, 5, 34], [1, 2, 35], [4, 5, 53], [0, 4, 75]] 159
5 [[0, 1, 5], [1, 2, 3], [2, 3, 3], [3, 1, 2], [3, 0, 4], [2, 4, 6], [4, 0, 7]] 15
5 [[0, 1, 1], [3, 4, 1], [1, 2, 2], [2, 3, 4]] 8
4 [[0, 1, 5], [1, 2, 3], [2, 3, 3], [1, 3, 2], [0, 3, 4]] 9
5 [[0, 1, 1], [3, 1, 1], [0, 2, 2], [0, 3, 2], [0, 4, 100]] 104
6 [[0, 1, 5], [0, 3, 2], [0, 4, 3], [1, 4, 1], [3, 4, 10], [1, 2, 2], [2, 5, 3], [4, 5, 4]] 11
5 [[0, 1, 1], [2, 3, 1], [3, 4, 2], [1, 2, 2], [0, 4, 100]] 6
5 [[0, 1, 1], [0, 4, 5], [2, 4, 1], [2, 3, 1], [3, 4, 1]] 8
5 [[0, 1, 1], [0, 2, 2], [0, 3, 3], [0, 4, 4], [1, 3, 1]] 8
5 [[0, 1, 1], [0, 2, 2], [1, 2, 5], [1, 3, 3], [2, 3, 8], [3, 4, 1]] 7
5 [[0, 1, 1], [3, 4, 1], [1, 2, 2], [2, 3, 4]] 8
4 [[0,1,1],[0,2,2],[2,3,1]] 4
"""